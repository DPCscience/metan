#' Weighted Average of Absolute Scores
#'
#' Compute the Weighted Average of Absolute Scores for quantifying the
#' stability in multienvironment trials using mixed-effect models.
#'
#' This function compute the weighted average of absolute scores considering
#' all principal component axis from the Singular Value Decomposition (SVD) of
#' the BLUP'S GxE effects matrix generated by a linear mixed-effect model. The
#' main advantage of this procedure in relation to the \code{WAAS.AMMI}
#' function is that random effects can be included in the model. In addition,
#' unbalanced datasets can also be modeled.
#'
#' @param .data The dataset containing the columns related to Environments,
#' Genotypes, replication/block and response variable(s).
#' @param env The name of the column that contains the levels of the
#' environments.
#' @param gen The name of the column that contains the levels of the genotypes.
#' @param rep The name of the column that contains the levels of the
#' replications/blocks.
#' @param resp The response variable(s). To analyze multiple variables in a
#' single procedure a vector of variables may be used. For example \code{resp =
#' c(var1, var2, var3)}.
#' @param mresp A numeric vector of the same length of \code{resp}. The
#' \code{mresp} will be the new maximum value after reescaling. By default, all
#' variables in \code{resp} are rescaled so that de maximum value is 100 and
#' the minimum value is 0.
#' @param wresp The weight for the response variable(s) for computing the
#' WAASBY index. Must be a numeric vector of the same length of \code{resp}.
#' Defatul is 50, i.e., equal weights for stability and mean performance.
#' @param random The effects of the model assumed to be random. Default is
#' \code{random = "gen"} (genotype and genotype-vs-environment as random
#' effects. Other values allowed are \code{random = "env"} (environment,
#' genotype-vs-environment and block-within-environment random effects) or
#' \code{random = "all"} all effects except the intercept are assumed to be
#' random effects.
#' @param prob The probability for estimating confidence interval for BLUP's
#' prediction.
#' @param verbose Logical argument. If \code{verbose = FALSE} the code are run
#' silently.
#' @return The function returns the results in a list for each analyzed
#' variable. For each variable, the following objects are returned.
#'
#' \item{individual}{A within-environments ANOVA considering a fixed-effect
#' model.}
#'
#' \item{fixed}{Test for fixed effects.}
#'
#' \item{random}{Variance components for random effects.}
#'
#' \item{LRT}{The Likelihood Ratio Test for the random effects.}
#'
#' \item{model}{A data frame with the response variable, the scores of all
#' Principal Components, the estimates of Weighted Average of Absolute Scores,
#' and WAASY (the index that consider the weights for stability and
#' productivity in the genotype ranking.}
#'
#' \item{blupGEN}{The estimated BLUPS for genotypes (If \code{random = "gen"}
#' or \code{random = "all"})}
#'
#' \item{BLUPenv}{The estimated BLUPS for environments, (If \code{random =
#' "env"} or \code{random = "all"}).}
#'
#' \item{BLUPge}{The estimated BLUPS of all genotypes in all environments
#' "BLUPij".}
#'
#' \item{PCA}{The results of Principal Component Analysis with eigenvalues and
#' explained variance of BLUP-interaction matrix.}
#'
#' \item{MeansGxE}{The phenotypic means of genotypes in the environments, with
#' observed, predicted and OLS residual prediction.}
#'
#' \item{Details}{A list summarizing the results. The following information are
#' showed. \code{WgtResponse}, the weight for the response variable in
#' estimating WAASB, \code{WgtWAAS} the weight for stability, \code{Ngen} the
#' number of genotypes, \code{Nenv} the number of environments, \code{OVmean}
#' the overall mean, \code{Min} the minimum observed (returning the genotype
#' and environment), \code{Max} the maximum observed, \code{Max} the maximum
#' observed, \code{MinENV} the environment with the lower mean, \code{MaxENV}
#' the environment with the larger mean observed, \code{MinGEN} the genotype
#' with the lower mean, \code{MaxGEN} the genotype with the larger.}
#'
#' \item{ESTIMATES}{A list with the following values: \code{GEV} the
#' genotype-by-environment variance (and percentage of phenotypic variance);
#' \code{GV} the genotypic variance (and percentage of phenotypic variance);
#' \code{EV} the environmental variance;\code{RV} the residual variance (and
#' percentage of phenotypic variance); \code{FV} the phenotypic variance;
#' \code{h2g} the heritability of the trait; \code{GEr2} the coefficient of
#' determination of the interaction effects; \code{h2mg} the heritability of
#' the mean; \code{AccuGen} the selective accuracy; \code{rge} the
#' genotype-environment correlation; \code{CVg} the genotypic coefficient of
#' variation; \code{CVr} the residual coefficient of variation; \code{CVratio}
#' the ratio between genotypic and residual coefficient of variation.}
#'
#' \item{residuals}{The residuals of the model.}
#' @author Tiago Olivoto \email{tiagoolivoto@@gmail.com}
#' @seealso \code{\link{WAAS.AMMI}}
#' @export
#' @examples
#'
#' library(metan)
#'
#' # Genotypes as random effects and equal weights for both
#'
#' # response variable and stability
#'
#' model <-  WAASB(data_ge,
#'                env = ENV,
#'                gen = GEN,
#'                rep = REP,
#'                resp = GY,
#'                wresp = 70)
#'
#' # Higher weight for response variable
#'
#' model2 <- WAASB(data_ge,
#'                env = ENV,
#'                gen = GEN,
#'                rep = REP,
#'                resp = GY,
#'                wresp = 65)
#'
#' # Environment as random effects analyzing more than one variables
#' # considering that smaller values of HM are better and higher
#' # values of GY are better, assigning a larger weight for the GY
#' # and a smaller weight for HM when computing WAASBY index.
#'
#' model3 <- WAASB(data_ge,
#'                 env = ENV,
#'                 gen = GEN,
#'                 rep = REP,
#'                 resp = c(GY, HM),
#'                 random = "env",
#'                 mresp = c(100, 0),
#'                 wresp = c(60, 40))
#'
#'

WAASB <- function(.data, env, gen, rep, resp, mresp = NULL, wresp = NULL, random = "gen",
                  prob = 0.05, verbose = TRUE) {
    if (!random %in% c("env", "gen", "all")) {
        stop("The argument 'random' must be one of the 'gen', 'env', or 'all'.")
    }
    d <- match.call()
    nvar <- as.numeric(ifelse(length(d$resp) > 1, length(d$resp) - 1, length(d$resp)))
    if (is.null(mresp)) {
        mresp <- replicate(nvar, 100)
        minresp <- 100 - mresp
    } else {
        if (length(mresp) != nvar) {
            stop("The length of the numeric vector 'mresp' must be equal the number of variables in argument 'resp'")
        }
        if (sum(mresp == 100) + sum(mresp == 0) != nvar) {
            stop("The values of the numeric vector 'mresp' must be 0 or 100.")
        }
        mresp <- mresp
        minresp <- 100 - mresp
    }

    if (is.null(wresp)) {
        PesoResp <- replicate(nvar, 50)
        PesoWAASB <- 100 - PesoResp
    } else {
        if (length(wresp) != nvar) {
            stop("The length of the numeric vector 'wresp' must be equal the number of variables in argument 'resp'")
        }
        if (min(wresp) < 0 | max(wresp) > 100) {
            stop("The range of the numeric vector 'wresp' must be equal between 0 and 100.")
        }
        PesoResp <- wresp
        PesoWAASB <- 100 - PesoResp
    }
    datain <- .data
    GEN <- factor(eval(substitute(gen), eval(datain)))
    ENV <- factor(eval(substitute(env), eval(datain)))
    REP <- factor(eval(substitute(rep), eval(datain)))
    listres <- list()
    vin <- 0
    if (random == "env") {
        for (var in 2:length(d$resp)) {
            if (length(d$resp) > 1) {
                Y <- eval(substitute(resp)[[var]], eval(datain))
                data <- data.frame(ENV, GEN, REP, Y)
            } else {
                Y <- eval(substitute(resp), eval(datain))
                data <- data.frame(ENV, GEN, REP, Y)
            }
            Nenv <- length(unique(ENV))
            Ngen <- length(unique(GEN))
            minimo <- min(Nenv, Ngen) - 1
            vin <- vin + 1
            Nbloc <- length(unique(REP))
            ovmean <- mean(Y)

            if (minimo < 2) {
                cat("\nWarning. The analysis is not possible.")
                cat("\nThe number of environments and number of genotypes must be greater than 2\n")
            }

            individual <- data %>% anova_ind(ENV, GEN, REP, Y)

            Complete <- lmerTest::lmer(data = data, Y ~ GEN + (1 | ENV/REP) + (1 |
                                                                                   GEN:ENV))
            LRT <- lmerTest::ranova(Complete, reduce.terms = FALSE)
            rownames(LRT) <- c("Complete", "Env/Rep", "Env", "Gen vs Env")
            random = lme4::VarCorr(Complete) %>%
                as.data.frame() %>%
                select(1, 4) %>%
                arrange(grp) %>%
                rename(Group = grp, Variance = vcov)
            fixed <- anova(Complete)
            ENVIR <- as.numeric(random[1, 2])
            GEV <- as.numeric(random[2, 2])
            BEV <- as.numeric(random[3, 2])
            RV <- as.numeric(random[4, 2])
            FV <- ENVIR + GEV + BEV + RV
            ENVper <- (ENVIR/FV) * 100
            GEVper <- (GEV/FV) * 100
            RVper <- (RV/FV) * 100
            BEVper <- (BEV/FV) * 100
            GEV <- paste0(round(GEV, 6), " (", round(GEVper, 2), "% of phenotypic variance.)")
            ENVIR <- paste0(round(ENVIR, 6), " (", round(ENVper, 2), "% of phenotypic variance.)")
            RV <- paste0(round(RV, 6), " (", round(RVper, 2), "% of phenotypic variance.)")
            BEV <- paste0(round(BEV, 6), " (", round(BEVper, 2), "% of phenotypic variance.)")
            ESTIMATES <- list(GEV = GEV, ENVIR = ENVIR, RV = RV, BEV = BEV, FV = FV)
            ESTIMATES <- do.call(rbind.data.frame, ESTIMATES)
            names(ESTIMATES) <- "Values"
            ESTIMATES <- dplyr::mutate(ESTIMATES, Parameters = c("GEI variance", "Environment variance",
                                                                 "Residual variance", "Env/block variance",
                                                                 "Phenotypic variance")) %>%
                dplyr::select(Parameters, everything())
            bups <- lme4::ranef(Complete)
            blups <- data.frame(Names = rownames(bups$`GEN:ENV`))
            blups = blups %>%
                data.frame(do.call("rbind",
                                   strsplit(as.character(blups$Names),
                                            ":", fixed = TRUE))) %>%
                dplyr::select(-Names) %>%
                dplyr::select(-X1, everything()) %>%
                dplyr::mutate(BLUPge = bups[[1]]$`(Intercept)`) %>%
                dplyr::rename(Code = X2, GEN = X1) %>%
                dplyr::arrange(Code)
            intmatrix <- by(blups[, 3], blups[, c(2, 1)], function(x) sum(x, na.rm = TRUE))
            s <- svd(intmatrix)
            U <- s$u[, 1:minimo]
            LL <- diag(s$d[1:minimo])
            V <- s$v[, 1:minimo]
            Eigenvalue <- data.frame(Eigenvalue = s$d[1:minimo]^2) %>%
                dplyr::mutate(Proportion = s$d[1:minimo]^2/sum(s$d[1:minimo]^2) * 100,
                              Accumulated = cumsum(Proportion),
                              PC = paste("PC", 1:minimo, sep = "")) %>%
                dplyr::select(PC, everything())
            SCOREG <- U %*% LL^0.5
            SCOREE <- V %*% LL^0.5
            colnames(SCOREG) <- colnames(SCOREE) <- paste("PC", 1:minimo, sep = "")
            MEDIAS <- data.frame(data %>% dplyr::group_by(ENV, GEN) %>% dplyr::summarise(Y = mean(Y)))
            MGEN = MEDIAS %>% group_by(GEN) %>% summarise(Y = mean(Y)) %>% mutate(type = "GEN")
            MGEN = cbind(MGEN, SCOREG)
            MENV = MEDIAS %>% group_by(ENV) %>% summarise(Y = mean(Y)) %>% mutate(type = "ENV")
            MENV = cbind(MENV, SCOREE)
            MEDIAS <- suppressMessages(dplyr::mutate(MEDIAS,
                                                     envPC1 = left_join(MEDIAS, MENV %>% select(ENV, PC1))$PC1,
                                                     genPC1 = left_join(MEDIAS, MGEN %>% select(GEN, PC1))$PC1,
                                                     nominal = left_join(MEDIAS, MGEN %>% select(GEN, Y))$Y + genPC1 * envPC1))
            MGEN = MGEN %>% rename(Code = GEN)
            MENV = MENV %>% rename(Code = ENV)
            Escores <- rbind(MGEN, MENV) %>% select(type, everything())
            Pesos <- data.frame(Percent = Eigenvalue$Proportion)
            WAASB <- Escores %>%
                select(contains("PC")) %>%
                abs() %>%
                t() %>%
                as.data.frame() %>%
                mutate(Percent = Pesos$Percent)
            WAASAbs <- mutate(Escores, WAASB = sapply(WAASB[, -ncol(WAASB)], weighted.mean, w = WAASB$Percent))
            if (nvar > 1) {
                WAASAbs %<>%
                    group_by(type) %>%
                    mutate(PctResp = (mresp[vin] - minresp[vin])/(max(Y) - min(Y)) * (Y - max(Y)) + mresp[vin],
                           PctWAASB = (minresp[vin] - mresp[vin])/(max(WAASB) - min(WAASB)) * (WAASB - max(WAASB)) + minresp[vin],
                           wRes = PesoResp[vin],
                           wWAASB = PesoWAASB[vin],
                           OrResp = rank(-Y),
                           OrWAASB = rank(WAASB),
                           OrPC1 = rank(abs(PC1)),
                           WAASBY = ((PctResp * wRes) + (PctWAASB * wWAASB))/(wRes + wWAASB),
                           OrWAASBY = rank(-WAASBY))
            } else {
                WAASAbs %<>%
                    group_by(type) %>%
                    mutate(PctResp = (mresp - minresp)/(max(Y) - min(Y)) * (Y - max(Y)) + mresp,
                           PctWAASB = (minresp - mresp)/(max(WAASB) - min(WAASB)) * (WAASB - max(WAASB)) + minresp,
                           wRes = PesoResp,
                           wWAASB = PesoWAASB,
                           OrResp = rank(-Y),
                           OrWAASB = rank(WAASB),
                           OrPC1 = rank(abs(PC1)),
                           WAASBY = ((PctResp * wRes) + (PctWAASB * wWAASB))/(wRes + wWAASB),
                           OrWAASBY = rank(-WAASBY))
            }

            min_group = Escores %>% group_by(type) %>% top_n(1, -Y) %>% select(type, Code, Y) %>% slice(1)
            max_group = Escores %>% group_by(type) %>% top_n(1, Y) %>% select(type, Code, Y) %>% slice(1)
            min = MEDIAS %>% top_n(1, -Y) %>% select(ENV, GEN, Y) %>% slice(1)
            max = MEDIAS %>% top_n(1, Y) %>% select(ENV, GEN, Y) %>% slice(1)
            Details <- list(Ngen = Ngen,
                            Nenv = Nenv,
                            OVmean = round(mean(MEDIAS$Y), 4),
                            Min = paste0(round(min[3], 4), " (Genotype ", min$GEN, " in ", min$ENV,")"),
                            Max = paste0(round(max$Y, 4), " (Genotype ", max$GEN, " in ", max$ENV,")"),
                            MinENV = paste0("Environment ", min_group[2,2], " (", round(min_group[2,3], 3),")"),
                            MaxENV = paste0("Environment ", max_group[2,2], " (", round(max_group[2,3], 3),")"),
                            MinGEN = paste0("Genotype ", min_group[1,2], " (", round(min_group[1,3], 3), ") "),
                            MaxGEN =  paste0("Genotype ", max_group[1,2], " (", round(max_group[1,3], 3), ") "))
            Details <- do.call(rbind.data.frame, Details)
            names(Details) <- "Values"
            Details <- dplyr::mutate(Details, Parameters = c("Ngen", "Nenv", "OVmean",
                                                             "Min", "Max", "MinENV", "MaxENV", "MinGEN", "MaxGEN"))%>%
                dplyr::select(Parameters, everything())


            Predicted <- data %>% mutate(Predicted = predict(Complete))
            residuals <- data.frame(fortify.merMod(Complete))
            temp <- structure(list(individual = individual[[1]], fixed = fixed, random = random,
                                   LRT = LRT, model = WAASAbs, BLUPgen = NULL, BLUPgge = Predicted,
                                   PCA = Eigenvalue, MeansGxE = MEDIAS, Details = Details, ESTIMATES = ESTIMATES,
                                   residuals = residuals), class = "WAASB")
            if (length(d$resp) > 1) {
                if (verbose == T) {
                    cat("Evaluating variable", paste(d$resp[var]), round((var - 1)/(length(d$resp) -
                                                                                        1) * 100, 1), "%", "\n")
                }
                listres[[paste(d$resp[var])]] <- temp
            } else {
                listres[[paste(d$resp)]] <- temp
            }
        }
    } else if (random == "gen") {
        for (var in 2:length(d$resp)) {
            if (length(d$resp) > 1) {
                Y <- eval(substitute(resp)[[var]], eval(datain))
                data <- data.frame(ENV, GEN, REP, Y)
            } else {
                Y <- eval(substitute(resp), eval(datain))
                data <- data.frame(ENV, GEN, REP, Y)
            }
            Nenv <- length(unique(ENV))
            Ngen <- length(unique(GEN))
            minimo <- min(Nenv, Ngen) - 1
            vin <- vin + 1
            Nbloc <- length(unique(REP))
            ovmean <- mean(Y)

            if (minimo < 2) {
                cat("\nWarning. The analysis is not possible.")
                cat("\nThe number of environments and number of genotypes must be greater than 2\n")
            }

            individual <- data %>% anova_ind(ENV, GEN, REP, Y)

            Complete <- suppressWarnings(suppressMessages(lmerTest::lmer(data = data,
                                                                         Y ~ REP %in% ENV + ENV + (1 | GEN) + (1 | GEN:ENV))))
            LRT <- lmerTest::ranova(Complete, reduce.terms = FALSE)
            fixed <- anova(Complete)
            rownames(LRT) <- c("Complete", "Genotype", "Gen vs Env")
            random = lme4::VarCorr(Complete) %>%
                as.data.frame() %>%
                select(1, 4) %>%
                arrange(grp) %>%
                rename(Group = grp, Variance = vcov)
            GV <- as.numeric(random[1, 2])
            GEV <- as.numeric(random[2, 2])
            RV <- as.numeric(random[3, 2])
            FV <- GEV + GV + RV
            h2g <- GV/FV
            h2mg <- GV/(GV + GEV/Nenv + RV/(Nenv * Nbloc))
            GEr2 <- GEV/(GV + GEV + RV)
            AccuGen <- sqrt(h2mg)
            rge <- GEV/(GEV + RV)
            CVg <- (sqrt(GV)/ovmean) * 100
            CVr <- (sqrt(RV)/ovmean) * 100
            CVratio <- CVg/CVr
            PROB <- ((1 - (1 - prob))/2) + (1 - prob)
            t <- qt(PROB, 100)
            Limits <- t * sqrt(((1 - AccuGen) * GV))
            GEVper <- (GEV/FV) * 100
            GVper <- (GV/FV) * 100
            RVper <- (RV/FV) * 100
            GEV <- paste0(round(GEV, 6), " (", round(GEVper, 2), "% of phenotypic variance.)")
            GV <- paste0(round(GV, 6), " (", round(GVper, 2), "% of phenotypic variance.)")
            RV <- paste0(round(RV, 6), " (", round(RVper, 2), "% of phenotypic variance.)")
            ESTIMATES <- list(GEV = GEV, GV = GV, RV = RV, FV = FV, h2g = h2g, GEr2 = GEr2,
                              h2mg = h2mg, AccuGen = AccuGen, rge = rge, CVg = CVg, CVr = CVr, CVratio = CVratio)
            ESTIMATES <- do.call(rbind.data.frame, ESTIMATES)
            names(ESTIMATES) <- "Values"
            ESTIMATES <- dplyr::mutate(ESTIMATES, Parameters = c("GEI variance", "Genotypic variance",
                                                                 "Residual variance", "Phenotypic variance", "Heritability", "GEIr2",
                                                                 "Heribatility of means", "Accuracy", "rge", "CVg", "CVr", "CV ratio"))
            ESTIMATES <- ESTIMATES %>% dplyr::select(Parameters, everything())
            bups <- lme4::ranef(Complete)
            blups <- data.frame(Names = rownames(bups$`GEN:ENV`))
            blups = blups %>%
                data.frame(do.call("rbind",
                                   strsplit(as.character(blups$Names),
                                            ":", fixed = TRUE))) %>%
                dplyr::select(-Names) %>%
                dplyr::select(-X1, everything()) %>%
                dplyr::mutate(BLUPge = bups[[1]]$`(Intercept)`) %>%
                dplyr::rename(Code = X2, GEN = X1) %>%
                dplyr::arrange(Code)
            intmatrix <- by(blups[, 3], blups[, c(2, 1)], function(x) sum(x, na.rm = TRUE))
            s <- svd(intmatrix)
            U <- s$u[, 1:minimo]
            LL <- diag(s$d[1:minimo])
            V <- s$v[, 1:minimo]
            Eigenvalue <- data.frame(Eigenvalue = s$d[1:minimo]^2) %>%
                dplyr::mutate(Proportion = s$d[1:minimo]^2/sum(s$d[1:minimo]^2) * 100,
                              Accumulated = cumsum(Proportion),
                              PC = paste("PC", 1:minimo, sep = "")) %>%
                dplyr::select(PC, everything())
            SCOREG <- U %*% LL^0.5
            SCOREE <- V %*% LL^0.5
            colnames(SCOREG) <- colnames(SCOREE) <- paste("PC", 1:minimo, sep = "")
            MEDIAS <- data.frame(data %>% dplyr::group_by(ENV, GEN) %>% dplyr::summarise(Y = mean(Y)))
            MGEN = MEDIAS %>% group_by(GEN) %>% summarise(Y = mean(Y)) %>% mutate(type = "GEN")
            MGEN = cbind(MGEN, SCOREG)
            MENV = MEDIAS %>% group_by(ENV) %>% summarise(Y = mean(Y)) %>% mutate(type = "ENV")
            MENV = cbind(MENV, SCOREE)
            MEDIAS <- suppressMessages(dplyr::mutate(MEDIAS,
                                                     envPC1 = left_join(MEDIAS, MENV %>% select(ENV, PC1))$PC1,
                                                     genPC1 = left_join(MEDIAS, MGEN %>% select(GEN, PC1))$PC1,
                                                     nominal = left_join(MEDIAS, MGEN %>% select(GEN, Y))$Y + genPC1 * envPC1))
            MGEN = MGEN %>% rename(Code = GEN)
            MENV = MENV %>% rename(Code = ENV)
            Escores <- rbind(MGEN, MENV) %>% select(type, everything())
            Pesos <- data.frame(Percent = Eigenvalue$Proportion)
            WAASB <- Escores %>%
                select(contains("PC")) %>%
                abs() %>%
                t() %>%
                as.data.frame() %>%
                mutate(Percent = Pesos$Percent)
            WAASAbs <- mutate(Escores, WAASB = sapply(WAASB[, -ncol(WAASB)], weighted.mean, w = WAASB$Percent))
            if (nvar > 1) {
                WAASAbs %<>%
                    group_by(type) %>%
                    mutate(PctResp = (mresp[vin] - minresp[vin])/(max(Y) - min(Y)) * (Y - max(Y)) + mresp[vin],
                           PctWAASB = (minresp[vin] - mresp[vin])/(max(WAASB) - min(WAASB)) * (WAASB - max(WAASB)) + minresp[vin],
                           wRes = PesoResp[vin],
                           wWAASB = PesoWAASB[vin],
                           OrResp = rank(-Y),
                           OrWAASB = rank(WAASB),
                           OrPC1 = rank(abs(PC1)),
                           WAASBY = ((PctResp * wRes) + (PctWAASB * wWAASB))/(wRes + wWAASB),
                           OrWAASBY = rank(-WAASBY))
            } else {
                WAASAbs %<>%
                    group_by(type) %>%
                    mutate(PctResp = (mresp - minresp)/(max(Y) - min(Y)) * (Y - max(Y)) + mresp,
                           PctWAASB = (minresp - mresp)/(max(WAASB) - min(WAASB)) * (WAASB - max(WAASB)) + minresp,
                           wRes = PesoResp,
                           wWAASB = PesoWAASB,
                           OrResp = rank(-Y),
                           OrWAASB = rank(WAASB),
                           OrPC1 = rank(abs(PC1)),
                           WAASBY = ((PctResp * wRes) + (PctWAASB * wWAASB))/(wRes + wWAASB),
                           OrWAASBY = rank(-WAASBY))
            }
            min_group = Escores %>% group_by(type) %>% top_n(1, -Y) %>% select(type, Code, Y) %>% slice(1)
            max_group = Escores %>% group_by(type) %>% top_n(1, Y) %>% select(type, Code, Y) %>% slice(1)
            min = MEDIAS %>% top_n(1, -Y) %>% select(ENV, GEN, Y) %>% slice(1)
            max = MEDIAS %>% top_n(1, Y) %>% select(ENV, GEN, Y) %>% slice(1)
            Details <- list(Ngen = Ngen,
                            Nenv = Nenv,
                            OVmean = round(mean(MEDIAS$Y), 4),
                            Min = paste0(round(min[3], 4), " (Genotype ", min$GEN, " in ", min$ENV,")"),
                            Max = paste0(round(max$Y, 4), " (Genotype ", max$GEN, " in ", max$ENV,")"),
                            MinENV = paste0("Environment ", min_group[2,2], " (", round(min_group[2,3], 3),")"),
                            MaxENV = paste0("Environment ", max_group[2,2], " (", round(max_group[2,3], 3),")"),
                            MinGEN = paste0("Genotype ", min_group[1,2], " (", round(min_group[1,3], 3), ") "),
                            MaxGEN =  paste0("Genotype ", max_group[1,2], " (", round(max_group[1,3], 3), ") "))
            Details <- do.call(rbind.data.frame, Details)
            names(Details) <- "Values"
            Details <- dplyr::mutate(Details, Parameters = c("Ngen", "Nenv", "OVmean",
                                                             "Min", "Max", "MinENV", "MaxENV", "MinGEN", "MaxGEN"))%>%
                dplyr::select(Parameters, everything())
            blupGEN <- data.frame(GEN = MGEN$Code, BLUPg = bups$GEN$`(Intercept)`) %>%
                dplyr::mutate(Predicted = BLUPg + ovmean) %>%
                dplyr::arrange(-Predicted) %>%
                dplyr::mutate(Rank = rank(Predicted),
                              LL = Predicted - Limits,
                              UL = Predicted + Limits) %>%
                dplyr::select(Rank, everything())
            selectioNenv <- suppressMessages(dplyr::left_join(blups, blupGEN %>% select(GEN, BLUPg))) %>%
                dplyr::mutate(gge = BLUPge + BLUPg,
                              Predicted = BLUPge + BLUPg + suppressMessages(left_join(blups, MENV %>% select(Code, Y))$Y),
                              LL = Predicted - Limits,
                              UL = Predicted + Limits)
            names(selectioNenv) <- c("ENV", "GEN", "BLUPge", "BLUPg", "BLUPg+ge",
                                     "Predicted", "LL", "UL")
            residuals <- data.frame(fortify.merMod(Complete))
            residuals$reff <- selectioNenv$BLUPge
            temp <- structure(list(individual = individual[[1]], fixed = fixed, random = random,
                                   LRT = LRT, model = WAASAbs, blupGEN = blupGEN, BLUPgge = selectioNenv,
                                   PCA = Eigenvalue, MeansGxE = MEDIAS, Details = Details, ESTIMATES = ESTIMATES,
                                   residuals = residuals), class = "WAASB")

            if (length(d$resp) > 1) {
                if (verbose == T) {
                    cat("Evaluating variable", paste(d$resp[var]), round((var - 1)/(length(d$resp) -
                                                                                        1) * 100, 1), "%", "\n")
                }
                listres[[paste(d$resp[var])]] <- temp
            } else {
                listres[[paste(d$resp)]] <- temp
            }
        }
    } else {
        for (var in 2:length(d$resp)) {
            if (length(d$resp) > 1) {
                Y <- eval(substitute(resp)[[var]], eval(datain))
                data <- data.frame(ENV, GEN, REP, Y)
            } else {
                Y <- eval(substitute(resp), eval(datain))
                data <- data.frame(ENV, GEN, REP, Y)
            }
            Nenv <- length(unique(ENV))
            Ngen <- length(unique(GEN))
            minimo <- min(Nenv, Ngen) - 1
            vin <- vin + 1
            Nbloc <- length(unique(REP))
            ovmean <- mean(Y)

            if (minimo < 2) {
                cat("\nWarning. The analysis is not possible.")
                cat("\nThe number of environments and number of genotypes must be greater than 2\n")
            }

            individual <- data %>% anova_ind(ENV, GEN, REP, Y)

            Complete <- suppressWarnings(suppressMessages(lmerTest::lmer(data = data,
                                                                         Y ~ (1 | GEN) + (1 | ENV/REP) + (1 | GEN:ENV))))
            LRT <- lmerTest::ranova(Complete, reduce.terms = FALSE)
            rownames(LRT) <- c("Complete", "Genotype", "Env/Rep", "Environment", "Gen:Env")
            random = lme4::VarCorr(Complete) %>%
                as.data.frame() %>%
                select(1, 4) %>%
                arrange(grp) %>%
                rename(Group = grp, Variance = vcov)
            EV <- as.numeric(random[1, 2])
            GV <- as.numeric(random[2, 2])
            GEV <- as.numeric(random[3, 2])
            BWE <- as.numeric(random[4, 2])
            RV <- as.numeric(random[5, 2])
            FV <- GEV + GV + EV + RV
            h2g <- GV/FV
            h2mg <- GV/(GV + GEV/Nenv + RV/(Nenv * Nbloc))
            GEr2 <- GEV/(GV + GEV + RV)
            AccuGen <- sqrt(h2mg)
            rge <- GEV/(GEV + RV)
            CVg <- (sqrt(GV)/ovmean) * 100
            CVr <- (sqrt(RV)/ovmean) * 100
            CVratio <- CVg/CVr
            PROB <- ((1 - (1 - prob))/2) + (1 - prob)
            t <- qt(PROB, 100)
            Limits <- t * sqrt(((1 - AccuGen) * GV))
            GEVper <- (GEV/FV) * 100
            GVper <- (GV/FV) * 100
            RVper <- (RV/FV) * 100
            EVper <- (EV/FV) * 100
            GEV <- paste0(round(GEV, 6), " (", round(GEVper, 2), "% of phenotypic variance.)")
            GV <- paste0(round(GV, 6), " (", round(GVper, 2), "% of phenotypic variance.)")
            RV <- paste0(round(RV, 6), " (", round(RVper, 2), "% of phenotypic variance.)")
            EV <- paste0(round(EV, 6), " (", round(EVper, 2), "% of phenotypic variance.)")
            ESTIMATES <- list(GEV = GEV, GV = GV, EV = EV, RV = RV, FV = FV, h2g = h2g,
                              GEr2 = GEr2, h2mg = h2mg, AccuGen = AccuGen, rge = rge, CVg = CVg,
                              CVr = CVr, CVratio = CVratio)
            ESTIMATES <- do.call(rbind.data.frame, ESTIMATES)
            names(ESTIMATES) <- "Values"
            ESTIMATES <- dplyr::mutate(ESTIMATES, Parameters = c("GEI variance", "Genotypic variance",
                                                                 "Environmental variance", "Residual variance", "Phenotypic variance",
                                                                 "Heritability", "GEIr2", "Heribatility of means", "Accuracy", "rge",
                                                                 "CVg", "CVr", "CV ratio")) %>%
                dplyr::select(Parameters, everything())
            bups <- lme4::ranef(Complete)
            blups <- data.frame(Names = rownames(bups$`GEN:ENV`))
            blups = blups %>%
                data.frame(do.call("rbind",
                                   strsplit(as.character(blups$Names),
                                            ":", fixed = TRUE))) %>%
                dplyr::select(-Names) %>%
                dplyr::select(-X1, everything()) %>%
                dplyr::mutate(BLUPge = bups[[1]]$`(Intercept)`) %>%
                dplyr::rename(ENV = X2, GEN = X1) %>%
                dplyr::arrange(ENV)
            intmatrix <- by(blups[, 3], blups[, c(2, 1)], function(x) sum(x, na.rm = TRUE))
            s <- svd(intmatrix)
            U <- s$u[, 1:minimo]
            LL <- diag(s$d[1:minimo])
            V <- s$v[, 1:minimo]
            Eigenvalue <- data.frame(Eigenvalue = s$d[1:minimo]^2) %>%
                dplyr::mutate(Proportion = s$d[1:minimo]^2/sum(s$d[1:minimo]^2) * 100,
                              Accumulated = cumsum(Proportion),
                              PC = paste("PC", 1:minimo, sep = "")) %>%
                dplyr::select(PC, everything())
            SCOREG <- U %*% LL^0.5
            SCOREE <- V %*% LL^0.5
            colnames(SCOREG) <- colnames(SCOREE) <- paste("PC", 1:minimo, sep = "")
            MEDIAS <- data.frame(data %>% dplyr::group_by(ENV, GEN) %>% dplyr::summarise(Y = mean(Y)))
            MGEN = MEDIAS %>% group_by(GEN) %>% summarise(Y = mean(Y)) %>% mutate(type = "GEN")
            MGEN = cbind(MGEN, SCOREG)
            MENV = MEDIAS %>% group_by(ENV) %>% summarise(Y = mean(Y)) %>% mutate(type = "ENV")
            MENV = cbind(MENV, SCOREE)
            MEDIAS <- suppressMessages(dplyr::mutate(MEDIAS,
                                                     envPC1 = left_join(MEDIAS, MENV %>% select(ENV, PC1))$PC1,
                                                     genPC1 = left_join(MEDIAS, MGEN %>% select(GEN, PC1))$PC1,
                                                     nominal = left_join(MEDIAS, MGEN %>% select(GEN, Y))$Y + genPC1 * envPC1))
            MGEN = MGEN %>% rename(Code = GEN)
            MENV = MENV %>% rename(Code = ENV)
            Escores <- rbind(MGEN, MENV) %>% select(type, everything())

            Pesos <- data.frame(Percent = Eigenvalue$Proportion)
            WAASB <- Escores %>%
                select(contains("PC")) %>%
                abs() %>%
                t() %>%
                as.data.frame() %>%
                mutate(Percent = Pesos$Percent)
            WAASAbs <- mutate(Escores, WAASB = sapply(WAASB[, -ncol(WAASB)], weighted.mean, w = WAASB$Percent))
            if (nvar > 1) {
                WAASAbs %<>%
                    group_by(type) %>%
                    mutate(PctResp = (mresp[vin] - minresp[vin])/(max(Y) - min(Y)) * (Y - max(Y)) + mresp[vin],
                           PctWAASB = (minresp[vin] - mresp[vin])/(max(WAASB) - min(WAASB)) * (WAASB - max(WAASB)) + minresp[vin],
                           wRes = PesoResp[vin],
                           wWAASB = PesoWAASB[vin],
                           OrResp = rank(-Y),
                           OrWAASB = rank(WAASB),
                           OrPC1 = rank(abs(PC1)),
                           WAASBY = ((PctResp * wRes) + (PctWAASB * wWAASB))/(wRes + wWAASB),
                           OrWAASBY = rank(-WAASBY))
            } else {
                WAASAbs %<>%
                    group_by(type) %>%
                    mutate(PctResp = (mresp - minresp)/(max(Y) - min(Y)) * (Y - max(Y)) + mresp,
                           PctWAASB = (minresp - mresp)/(max(WAASB) - min(WAASB)) * (WAASB - max(WAASB)) + minresp,
                           wRes = PesoResp,
                           wWAASB = PesoWAASB,
                           OrResp = rank(-Y),
                           OrWAASB = rank(WAASB),
                           OrPC1 = rank(abs(PC1)),
                           WAASBY = ((PctResp * wRes) + (PctWAASB * wWAASB))/(wRes + wWAASB),
                           OrWAASBY = rank(-WAASBY))
            }

            min_group = Escores %>% group_by(type) %>% top_n(1, -Y) %>% select(type, Code, Y) %>% slice(1)
            max_group = Escores %>% group_by(type) %>% top_n(1, Y) %>% select(type, Code, Y) %>% slice(1)
            min = MEDIAS %>% top_n(1, -Y) %>% select(ENV, GEN, Y) %>% slice(1)
            max = MEDIAS %>% top_n(1, Y) %>% select(ENV, GEN, Y) %>% slice(1)
            Details <- list(Ngen = Ngen,
                            Nenv = Nenv,
                            OVmean = round(mean(MEDIAS$Y), 4),
                            Min = paste0(round(min[3], 4), " (Genotype ", min$GEN, " in ", min$ENV,")"),
                            Max = paste0(round(max$Y, 4), " (Genotype ", max$GEN, " in ", max$ENV,")"),
                            MinENV = paste0("Environment ", min_group[2,2], " (", round(min_group[2,3], 3),")"),
                            MaxENV = paste0("Environment ", max_group[2,2], " (", round(max_group[2,3], 3),")"),
                            MinGEN = paste0("Genotype ", min_group[1,2], " (", round(min_group[1,3], 3), ") "),
                            MaxGEN =  paste0("Genotype ", max_group[1,2], " (", round(max_group[1,3], 3), ") "))
            Details <- do.call(rbind.data.frame, Details)
            names(Details) <- "Values"
            Details <- dplyr::mutate(Details, Parameters = c("Ngen", "Nenv", "OVmean",
                                                             "Min", "Max", "MinENV", "MaxENV", "MinGEN", "MaxGEN"))%>%
                dplyr::select(Parameters, everything())

            blupGEN <- data.frame(GEN = MGEN$Code, BLUPg = bups$GEN$`(Intercept)`) %>%
                dplyr::mutate(Predicted = BLUPg + ovmean) %>%
                dplyr::arrange(-Predicted) %>%
                dplyr::mutate(Rank = rank(-Predicted),
                              LL = Predicted - Limits,
                              UL = Predicted + Limits) %>%
                dplyr::select(Rank, everything())

            blupENV <- data.frame(ENV = MENV$Code, BLUPe = bups$ENV$`(Intercept)`) %>%
                dplyr::mutate(Predicted = BLUPe + ovmean) %>%
                dplyr::arrange(-Predicted) %>%
                dplyr::mutate(Rank = rank(-Predicted),
                              LL = Predicted - Limits,
                              UL = Predicted + Limits) %>%
                dplyr::select(Rank, everything())

            selectioNenv <- suppressMessages(dplyr::left_join(blups, blupGEN %>% select(GEN, BLUPg))) %>%
                dplyr::mutate(BLUPe = suppressMessages(left_join(blups, blupENV %>% select(ENV, BLUPe))$BLUPe),
                              ggee = BLUPge + BLUPg + BLUPe,
                              Predicted = ggee + ovmean)
            names(selectioNenv) <- c("ENV", "GEN", "BLUPge", "BLUPg", "BLUPe", "BLUPge+g+e", "Predicted")
            residuals <- fortify.merMod(Complete)
            residuals$reff <- selectioNenv$BLUPge
            temp <- structure(list(individual = individual[[1]], fixed = NULL, random = random,
                                   LRT = LRT, model = WAASAbs, blupGEN = blupGEN, BLUPgge = selectioNenv,
                                   PCA = Eigenvalue, MeansGxE = MEDIAS, Details = Details, ESTIMATES = ESTIMATES,
                                   residuals = residuals), class = "WAASB")

            if (length(d$resp) > 1) {
                if (verbose == T) {
                    cat("Evaluating variable", paste(d$resp[var]), round((var - 1)/(length(d$resp) -
                                                                                        1) * 100, 1), "%", "\n")
                }
                listres[[paste(d$resp[var])]] <- temp
            } else {
                listres[[paste(d$resp)]] <- temp
            }
        }
    }
    if (verbose == T) {
        if (length(which(unlist(lapply(listres, function(x) {
            x[["LRT"]][3, 6]
        })) > prob)) > 0) {
            cat("------------------------------------------------------------\n")
            cat("Variables with nonsignificant GxE interaction\n")
            cat(names(which(unlist(lapply(listres, function(x) {
                x[["LRT"]][3, 6]
            })) > prob)), "\n")
            cat("------------------------------------------------------------\n")
        }
        cat("Done!\n")
    }
    invisible(structure(listres, class = "WAASB"))

}
