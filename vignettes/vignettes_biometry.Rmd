---
title: "Useful functions for biometrical models"
author: "Tiago Olivoto"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
link-citations: true
bibliography: metanref.bib 
vignette: >
  %\VignetteIndexEntry{Indexes for simultaneous selection}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r global_options, include = FALSE}
knitr::opts_chunk$set(comment = "", cache = TRUE)

```




```{r, message=FALSE, fig.height = 5, fig.width = 5.5, fig.align = "center" }
library(metan)
library(cowplot)
library(kableExtra) # Used to make the tables
library(tidyverse) # used for the forward-pipe operator %>%
# Function to make HTML tables
print_table = function(table){
  kable(table, "html", digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  font_size = 12)
}

```

# Find possible outliers in a data frame
The function `find_outlier()` may be used to identify possible outliers in a dataframe. It is suggested that before applying any statistical procedures, outliers be checked out.

```{r, message=FALSE, fig.height = 5, fig.width = 5.5, fig.align = "center" }
data_out = data_ge2
data_out[12, 4] = 5
find_outliers(data_out, var = PH, plots = TRUE)
```


To check the outliers in different levels of a factor, the function `split_factors()` is used. As an example, we will find possible outliers for each level of the factor `ENV`.

```{r, message=FALSE, fig.height = 5, fig.width = 5.5, fig.align = "center" }
data_ge2 %>%
  split_factors(ENV) %>%
  find_outliers(PH)
```


# Descriptive statistics
The function `desc_stat()` may be used to compute measures of central tendency, position, and dispersion. By default, seven statistics (coefficient of variation, maximum, mean, median, minimum,  standard error, and sample variance) are computed. To compute all the statistics, use the argument `stats = "all"`, or use a comma-separated vector with the statistic names, e.g., `stats = c("mean, CV")`. Use `hist = TRUE` to create a histogram for each variable.

```{r, message=FALSE, fig.height = 5, fig.width = 10, fig.align = "center" }
data_ge2 %>%
  desc_stat(EP, EL, CL, CD, CW, NR,
            hist = TRUE) %>% 
  print()
```

To compute the statistics for each level of a factor, use the function `split_factor()` before calling `desc_stat()`. In addition, it is possible to select the statistics to compute using the argument `stats`, that is a comma-separated vector of names with `"` at the beginning and end of vector only.

* This will work: 
   * `stats = c("mean, SE.mean, CV, max, min")`
   * `stats = "mean"`
   
* This will NOT work: 
   * `stats = c("mean, "SE.mean", "CV", "max", "min")`
   * `stats = c("mean,SE.mean, CV, max,min")`
   

```{r, message=FALSE, fig.height = 5, fig.width = 5.5, fig.align = "center" }
stats <- 
  data_ge2 %>%
  split_factors(GEN) %>%
  desc_stat(EP, EL, CL, CD, CW, NR,
            stats = c("mean, SE.mean, CV, max, min, median"),
            verbose = F)
print(stats)
```

We may convert the results above into a *wider* format by using the function `desc_wider()`

```{r, message=FALSE, fig.height = 5, fig.width = 5.5, fig.align = "center" }
desc_wider(stats, CD)
```


# Correlations
## Linear and partial correlation coefficients

Pearson's linear correlation does not consider the influence a set of traits on the relationship between two traits. For example, the hypothetical correlation of *r* = 0.9 between *x* and *y* may be due to the influence of a third trait or group of traits acting together. To identify this linear effect between *x* and *y* controlling statistically the effect of others traits, the partial correlation is used. From Pearson's simple correlation matrix, the partial correlation is calculated by the following equation:

$$
	{r_{xy.m}} = \frac{{ - {a_{xy}}}}{{\sqrt {{a_{xx}}{a_{yy}}} }}
$$

Where ${r_{xy.m}}$ is the partial correlation coefficient between the traits * x * and * y *, excluding the effects of the * m * remaining traits of the set; $- {a_{ij}}$ is the inverse element of the correlation matrix corresponding to xy, ${a_{ii}}{a_{jj}}$ are the diagonal elements of the inverse matrix of correlation associated with trait x and y , respectively. The significance of this correlation is also tested by the test * t * according to the following expression:


$$
t_{calc} = r_{xy.m} \sqrt \frac{n-v}{1-r_{xy.m}^2} 
$$

Where $t_{calc}$ is the calculated Student * t * statistic; $ r_{xy.m} $ is the partial correlation coefficient for the traits x and y excluding the effect of the other * m * traits; * n * is the number of observations; and * v * is the number of traits. Both the linear and partial correlation coefficients may be obtained using the function `lpcor()`.


```{r, message=FALSE }

lpc1 = data_ge2 %>% 
  select(starts_with("N")) %>% 
  lpcor(verbose = FALSE)
print_table(lpc1$results)

# Compute the correlations for each level of the factor ENV
lpc2 = data_ge2 %>%
       split_factors(ENV) %>%
       lpcor(verbose = FALSE) # Don't show the result in the console

    ```


Using the `pairs_mantel()` function, it is possible to compute a Mantel's test [@Mantel1967] for all pairwise correlation matrices of the above example. 

```{r, fig.height = 5, fig.width = 5.5, fig.align = "center" }
lpc2 %>% pairs_mantel(names = paste("H", 1:4, sep = ""))


    ```

This same plot may be obtained by passing correlation matrices with the same dimension to an object of class `lpcor` and then applying the function `pairs_mantel()`.

```{r, fig.height = 5, fig.width = 5.5, fig.align = "center" }
as.lpcor(cor(data_ge2[1:30, 5:ncol(data_ge2)]),
         cor(data_ge2[31:60, 5:ncol(data_ge2)]),
         cor(data_ge2[61:90, 5:ncol(data_ge2)]),
         cor(data_ge2[91:120, 5:ncol(data_ge2)]),
         cor(data_ge2[121:150, 5:ncol(data_ge2)])) %>%
  pairs_mantel(diag = TRUE,
               pan.spacing = 0,
               shape.point = 21,
               col.point = "black",
               fill.point = "red",
               size.point = 1.5,
               alpha.point = 0.6,
               main = "My own plot",
               alpha = 0.2)
    ```




## Graphical and numerical visualization of a correlation matrix

The function `corr_plot()` may be used to visualize (both graphically and numerically) a correlation matrix. Pairwise of scatterplots are produced and may be shown in the upper or lower diagonal, which may be seen as a nicer and customizable ggplot2-based version of the `pairs()`base R function.

```{r, fig.height = 5, fig.width = 5.5, fig.align = "center" }
corr_plot(data_ge2, CD, EL, PERK, NKR)


corr_plot(data_ge2, CD, EL, PERK, NKR,
          lower = NULL,
          upper = "corr")

corr_plot(data_ge2, CD, EL, PERK, NKR,
          shape.point = 19,
          size.point = 2,
          alpha.point = 0.5,
          alpha.diag = 0,
          pan.spacing = 0,
          diag.type = "boxplot",
          col.sign = "gray",
          alpha.sign = 0.3,
          axis.labels = TRUE)


corr_plot(data_ge2, CD, EL, PERK, NKR, CW, NKE,
          prob = 0.01,
          shape.point = 21,
          col.point = "black",
          fill.point = "orange",
          size.point = 2,
          alpha.point = 0.6,
          maxsize = 4,
          minsize = 2,
          smooth = TRUE,
          size.smooth = 1,
          col.smooth = "black",
          col.sign = "cyan",
          col.up.panel = "black",
          col.lw.panel = "black",
          col.dia.panel = "black",
          pan.spacing = 0,
          lab.position = "tl")

```


## (co)variance and correlations for designed experiments

The function `covcor_design()` may be used to compute genetic, phenotypic and residual correlation/(co)variance matrices through Analysis of Variance (ANOVA) method using randomized complete block design (RCBD) or completely randomized design (CRD).

The phenotypic ($r_p$), genotypic ($r_g$) and residual ($r_r$) correlations are computed as follows:

$$
r^p_{xy} = \frac{cov^p_{xy}}{\sqrt{var^p_{x}var^p_{y}}} \
r^g_{xy} = \frac{cov^g_{xy}}{\sqrt{var^g_{x}var^g_{y}}} \
r^r_{xy} = \frac{cov^r_{xy}}{\sqrt{var^r_{x}var^r_{y}}}
$$

Using Mean Squares (*MS*) from the ANOVA method, the variances (*var*) and covariances (*cov*) are computed as follows:

$$
cov^p_{xy} = [(MST_{x+y} - MST_x - MST_y)/2]/r \\
var^p_x = MST_x / r \\
var^p_y = MST_y / r
$$


$$
cov^r_{xy} = (MSR_{x+y} - MSR_x - MSR_y)/2 \\
var^r_x = MSR_x \\
var^r_y = MSR_y 
$$

$$
cov^g_{xy} = [(cov^p_{xy} \times r) - cov^r_{xy}]/r \\
var^g_x = (MST_x - MSE_x)/r \\
var^g_y = (MST_x - MSE_y)/r 
$$

where *MST* is the mean square for treatment, *MSR* is the mean square for residuals, and *r* is the number of replications.

The function `covcor_design()` returns a list with the matrices of (co)variances and correlations. Specific matrices may be returned using the argument `type`, as shown bellow.

## Genetic correlations
```{r, fig.height = 5, fig.width = 5.5, fig.align = "center" }
data = subset(data_ge2, ENV == "A1")
gcor = covcor_design(data, gen = GEN, rep = REP,
                     resp = c(PH, EH, NKE, TKW),
                     type = "gcor")
print_table(gcor)
```


## Phenotypic correlations
```{r, fig.height = 5, fig.width = 5.5, fig.align = "center" }
pcor = covcor_design(data, gen = GEN, rep = REP,
                     resp = c(PH, EH, NKE, TKW),
                     type = "pcor")
print_table(pcor)
    ```

## Residual correlations
```{r, fig.height = 5, fig.width = 5.5, fig.align = "center" }
rcor = covcor_design(data, gen = GEN, rep = REP,
                     resp = c(PH, EH, NKE, TKW),
                     type = "rcor")
print_table(rcor)
```

## Residual (co)variance matrix
Using the function `split_factors()` it is possible to pass the data grouped and compute the matrices for each level of the grouping factor. In this example we will obtain the residual (co)variance for each environment.

```{r, fig.height = 5, fig.width = 5.5, fig.align = "center", message=FALSE, warning=FALSE }
cov = data_ge2 %>%
      split_factors(ENV, keep_factors = TRUE) %>%
      covcor_design(GEN, REP, c(PH, EH, NKE, TKW),
                    type = "rcov")
    ```

The residual (co)variance matrix and the means (obtained using `type = "means"`) may be used into the function `mahala()` to compute the Mahalanobis distance 
```{r, fig.height = 5, fig.width = 5.5, fig.align = "center", message=FALSE, warning=FALSE }
res = data %>% # environment A1
      covcor_design(GEN, REP, c(PH, EH, NKE, TKW), type = "rcov")
means = data %>% # environment A1
      covcor_design(GEN, REP, c(PH, EH, NKE, TKW), type = "means")

D2 = mahala(.means = means, covar = res, inverted = FALSE)
print_table(D2)
    ```



## Nonparametric confidence interval for Pearson's correlation

Recently, a Gaussian-independent estimator for the confidence interval of Pearson's correlation coefficient was proposed by @Olivoto2018. This estimator is based on the sample size and strength of associations and may be estimated using the function `corr_ci()`. It is possible to estimate the confidence interval by declaring the sample size (n) and the correlation coefficient (r), or using a dataframe. The following code computes the confidence interval and make a plot to show the results.

```{r fig.width=7, fig.height = 5, fig.align="center"}

# Use a data frame
data_ge2 %>% 
select(contains("E")) %>%
corr_ci(verbose = FALSE) %>%
plot_ci()


```

In the following examples, the confidence interval is calculated by declaring the sample size (n) and the correlation coefficient (r). If the function `split_factors()` is used before `corr_ci()` then the confidence interval will be calculated within each level of the splitting factor.

```{r, fig.width=6, fig.height = 4, fig.align="center"}
# Inform n and r
corr_ci(n = 145, r = 0.34)

# Compute the confidence for each level of ENV
CI2 = data_ge2 %>% 
  select(contains("E")) %>%
  split_factors(ENV, verbose = FALSE) %>% 
  corr_ci()
```



## Sample size planning

```{r}
corr_ss(r = 0.6, CI = 0.1)

```


# Collinearity diagnostic

The following codes compute a complete collinearity diagnostic of a correlation matrix of predictor traits. Several indicators, such as Variance Inflation Factor, Condition Number, and Matrix Determinant are considered [@Olivoto2017f; @Olivoto2017c] The diagnostic may be performed using: (i) correlation matrices; (ii) dataframes, or (iii) an object of class `group_factor`, which split a dataframe into subsets based on one or more grouping factors.

## Using a correlation matrix, which was estimated earlier

```{r }
cor_data = lpc1$linear.mat
n = nrow(data_ge2)
cold1 = colindiag(cor_data, n = n)

```

## Using a dataframe

```{r }
cold2 = colindiag(data_ge2)

```


## Perform the diagnostic for each level of the factor ENV

```{r }
cold3 =  data_ge2 %>% 
         split_factors(ENV, verbose = FALSE) %>% 
         colindiag()
```



# Path analysis
## Using KW as response trait and all other ones as predictors.

```{r }
pcoeff = data_ge2 %>%
         path_coeff(resp = KW)
```


## Declaring the predictor traits

```{r }
pcoeff2 = data_ge2 %>%
  path_coeff(resp = KW,
             pred = c(PH, NKE, TKW),
             verbose = FALSE)
print(pcoeff2)
```


## Selecting traits to be excluded from the analysis.

```{r }
pcoeff2 = data_ge2 %>%
  path_coeff(resp = KW,
             pred = c(PH, EH, NKE, TKW),
             exclude = TRUE,
             verbose = FALSE)
```


## Selecting a set of predictors with minimal multicollinearity
```{r }
pcoeff3 = data_ge2 %>%
  path_coeff(resp = KW,
             brutstep = TRUE,
             maxvif = 5)
```


## Compute the analysis for each level of environment
```{r }
pcoeff4 = data_ge2 %>%
  split_factors(ENV) %>%
  path_coeff(resp = KW,
             pred = c(PH, EH, NKE, TKW))
```


# Canonical correlation analysis

```{r }
cc1 = can_corr(data_ge2,
               FG = c(PH, EH, EP),
               SG = c(EL, ED, CL, CD, CW, KW, NR))

cc2 = can_corr(FG = data_ge2[, 4:6],
               SG = data_ge2[, 7:13],
               verbose = FALSE,
               collinearity = FALSE)
```



# Clustering analysis
## Using function clustering()
### All rows and all numeric variables from data 

```{r, fig.height = 5, fig.width = 5.5, fig.align = "center"}
d1 = clustering(data_ge2)
```

### Based on the mean for each genotype

```{r, fig.height = 5, fig.width = 5.5, fig.align = "center"}
d2 = clustering(data_ge2, means_by = GEN, nclust = 2)
```

The S3 generic function plot() may be used to plot the dendrogram generated by the function `clustering()`. A dashed line is draw at the cutpoint suggested according to @Mojena1977.
```{r, fig.height = 5, fig.width = 5.5, fig.align = "center"}
plot(d2, lty = 2)
```
According to the suggested cutpoint, two clusters are formed. The number of clusters may also be found using intensive computation. I suggest the package [pcvlust](http://stat.sys.i.kyoto-u.ac.jp/prog/pvclust/), an R package for assessing the uncertainty in hierarchical cluster analysis. The implementation may be see below.

```{r, fig.height = 5, fig.width = 5.5, fig.align = "center"}
library(pvclust)
pv_clust <- pvclust(t(d2$data), nboot = 100, method.dist = "euclidean")
plot(pv_clust, hang = -1, cex = 0.5)
pvrect(pv_clust, alpha = 0.95)
```


### Indicating the variables to compute the distances
It is possible to indicate the variables from the data_ge2 to compute the distances. To do that is easy. You should only provide a comma-separated list of unquoted variable names after the .data argument. For example, to compute the distances between the genotypes based on the variables NKR, TKW, and NKE, the following arguments should be used.
 
```{r, fig.height = 5, fig.width = 5.5, fig.align = "center"}
d3 = clustering(data_ge2, NKR, TKW, NKE, means_by = GEN)
```

### Select variables for compute the distances
When `selvar = TRUE` is used, an algorithm for variable selection is implemented. See `?clustering` for more details.
```{r, fig.height = 5, fig.width = 5.5, fig.align = "center", message=FALSE, warning=FALSE}
d4 = clustering(data_ge2, means_by = GEN, selvar = TRUE)
```
The distances were computed using the variables ED, CW, KW, NKR, TKW, and NKE. By using these variables the highest cophenetic correlation coefficient (0.8658) was observed. The Mantel's correlation estimated with the distance matrix of Model 10 (selected variables) with the original distance matrix (estimated with all variables) was near to 1, suggesting that the deletion of the variables to compute the distance don't affect significantly the computation of the distances.

### Extending the dendrogram Functionality
The package [dendextend](https://cran.r-project.org/web/packages/dendextend/vignettes/introduction.html) offers a set of functions for extending 'dendrogram' objects in R. A simple example is given bellow. 

```{r, fig.height = 5, fig.width = 5.5, fig.align = "center", message=FALSE, warning=FALSE}
library(dendextend)
d4$hc %>%
  color_labels(k = 2, col = c("red", "blue")) %>%
  branches_color(k = 2, col = c("red", "blue")) %>%
  highlight_branches_lwd() %>%
plot(horiz = TRUE, xlab = "Euclidean distance")
```


### Compute the distances with standardized data

```{r, fig.height = 5, fig.width = 5.5, fig.align = "center"}
d5 = clustering(data_ge2,
                means_by = GEN,
                scale = TRUE)
```

### Compute the distances for each environment
* All rows of each environment and all numeric variables used

```{r, fig.height = 5, fig.width = 5.5, fig.align = "center"}
d6 = data_ge2 %>%
     split_factors(ENV) %>%
     clustering()
```

* Select the variables NKR, TKW, and NKE
* Use the mean for each genotype

```{r, fig.height = 5, fig.width = 5.5, fig.align = "center"}
d7 = data_ge2 %>%
  split_factors(ENV, keep_factors = TRUE) %>%
  clustering(NKR, TKW, NKE,
             means_by = GEN)
```

### Check the correlation between distance matrices
The function `pairs_mantel()` may be used to check the relationships between the distance matrices when the clustering is performed for each level of a grouping factor. In this example, we have four distance matrices corresponding to four environments.
```{r, fig.height = 5, fig.width = 5.5, fig.align = "center"}
pairs_mantel(d7, names = c("A1", "A2", "A3", "A4"))

```

The highest degree of association (0.36) was observed between **A1** and **A4**. The low values of correlation between the distance matrices suggest that the genotype clustering should vary significantly among environments.

## Mahalanobis distance
### Based on designed experiments

```{r }
# Environment E1
data_E1 = subset(data_ge2, ENV == "A1")
D2_des = mahala_design(data_E1,
                       gen = GEN,
                       rep = REP,
                       resp = c(ED, CW, KW, NKR, TKW, NKE))
print_table(D2_des)
```

### Compute one distance for each environment
Using the function `split_factors()` it is possible to compute the Mahalanobis distance for each environment (or any grouping variable) and compare the distance matrices using the function `pairs_mantel()`. Let's do it.
```{r, fig.height = 5, fig.width = 5.5, fig.align = "center"  }
data_ge2 %>%
split_factors(ENV, keep_factors = TRUE) %>%
mahala_design(gen = GEN,
              rep = REP,
              resp = c(ED, CW, KW, NKR, TKW, NKE)) %>%
pairs_mantel()

    ```

### If I have the matrices of means and covariances
Lets suppose we want compute the Mahalanobis' distance for each pairwise genotype comparision based on cob-related traits. Note that the function `select(contains("C"))` is used to select the cob-relate traits, after computing the mean for each genotype.

```{r }
means = data_ge2 %>%
  select(-c(ENV, REP)) %>%
  group_by(GEN) %>%
  summarise_all(mean) %>%
  column_to_rownames("GEN") %>%
  select(contains("C"))

```

The next step is to compute the variance-covariance matrix for the means. The first approach combines R base functions with some functions from **metan** package to compute the covariance matrix. Of course, the simplest way is by using `cov()`.

```{r }
# Compute the covariance matrix (by hand)
cov_mat = matrix(0, 4, 4)
diag(cov_mat) <- diag(var(means))
dev_scores <- sweep(means, 2, colMeans(means), FUN = "-")
comb_v <- comb_vars(dev_scores, FUN = "*")
cov_mat[lower.tri(cov_mat, diag = F)] <- colSums(comb_v/(nrow(means)-1))
rownames(cov_mat) <- colnames(cov_mat) <- colnames(means)
cov_mat <- make_sym(cov_mat)

# Compute the covariance using cov()
covmat2 = cov(means)

    ```

After computing the means and covariance matrices we are able to compute the Mahalanobis distance using the function `mahala()`.

```{r, fig.height = 5, fig.width = 5.5, fig.align = "center"}
D2 = mahala(means, covar = cov_mat)

# Dendrogram
D2 %>% as.dist() %>% hclust() %>% as.dendrogram() %>% plot()


    ```




#References

