---
title: "Multi-environment Trial Analysis"
author: "Tiago Olivoto"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
fig_caption: yes
link-citations: true
bibliography: metanref.bib    
vignette: >
  %\VignetteIndexEntry{Multi-environment Trial Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(comment = "")

```


# Brief examples

Brief examples will be shown using the dataset `data_ge` that contains data on two variables assessed in 10 genotypes growing in 11 environments. For more details see `?data_ge`.

```{r, message=FALSE, warning=FALSE}
library(metan)
library(cowplot) # used to arrange the graphics
library(kableExtra) # Used to make the tables

# Function to make HTML tables
print_table = function(table){
  kable(table, "html", digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed",        "responsive"), font_size = 12)
}
str(data_ge)
```


# AMMI model
## Cross-validation procedures
The cross-validation procedures implemented in the \bold{metan} are based on the splitting of the original data into a training set and a validation set. The model is fitted using the training set and the predicted value is compared with the validation set. This process is iterated many times, say, 1000 times. The lesser the difference between predicted and validation data, the higher the predictive accuracy of the model. More information may be found [here.](https://tiagoolivoto.github.io/metan/articles/vignettes_cross-validation.html)

```{r, fig.height=3.5, fig.width=5}
CVAL = cv_ammif(data_ge,
                env = ENV,                
                gen = GEN,
                rep = REP,
                resp = GY,
                nboot = 50)
plot(CVAL)
```


### Fitting the model
The AMMI model may be fitted with with both functions `performs_ammi()` and `waas()`, which is the acronym for the weighted average of absolute scores [@Olivoto2019].

```{r}
ammi_model <- performs_ammi(data_ge, ENV, GEN, REP, resp = c(GY, HM))
waas_index <- waas(data_ge, ENV, GEN, REP, GY, verbose = FALSE)
```

### Biplots

The well-known AMMI2 biplot may be obtained using the function `plot_scores()`. ggplot2-based graphics are obtained. Please, note that since `performs_ammi()` and , `waas()` functions allow analyzing multiple variables at the same time, e.g., `resp = c(v1, v2, ...)`, the output `ammi_model` is a list that in this case has two elements, (GY and HM).

```{r, fig.height=8, fig.width=5,  message=FALSE, warning=FALSE}
p1 <- plot_scores(ammi_model$GY, axis.expand = 1.2)
p2 <- plot_scores(ammi_model$GY,
                  type = 2,
                  polygon = TRUE,
                  col.gen = "black",
                  col.env = "gray70",
                  col.segm.env = "gray70",
                  axis.expand = 1.5)
plot_grid(p1, p2,
          align = "v",
          labels = c("p1","p2"),
          ncol = 1)
```


### S3 method predict()
The S3 method `predict()` is implemented for objects of class `performs_ammi` and may be used to estimate the response of each genotype in each environment considering different number of Interaction Principal Component Axis (IPCA). As a example, to predict the variables GY and HM we will use four and six IPCA (number of significant IPCAs, respectively).

```{r }
predicted <- predict(ammi_model, naxis = c(4, 6))
print_table(head(predicted$GY))
```

# BLUP model
The implementation of linear-mixed effect models to predict the response variable in MET is made with `waasb()` function. The *mixed-effect version* of the already fitted AMMI model, where genotype and genotype-vs-environment interaction are assumed to have random effects is then obtained as follows.

```{r }
model2 <- waasb(data_ge, ENV, GEN, REP, GY)
```

The mixed-effect model fitted in `model2` has many outputs. For example, we can easely obtain the Likelihood Ration Test for random effects, the variance components, and the BLUPs for genotypes as follows:

## Residual plots
Several residual plots may be obtained applying the function `autoplot()` to an object of class `waasb` (or `waas`). 

```{r,fig.height=12, fig.width=4}
library(ggplot2)
autoplot(model2$GY, which = c(1, 2, 7), mfrow = c(3,1))
```

## Distribution of random effects
The distribution of the random effects may be obtained using the argument
`type = "re"`.

```{r,fig.height=8, fig.width=4}
autoplot(model2$GY, type = "re", which = c(1, 2), mfrow = c(2,1))
```



```{r }
print_table(model2$GY$LRT)

print_table(model2$GY$random)

print_table(model2$GY$ESTIMATES)

print_table(model2$GY$blupGEN)
```

An easy way to check the results in the R console is by using the function `print()`


## Plotting the BLUPs for genotypes

```{r, fig.height=8, fig.width=4}
p1 <- plot_blup(model2$GY)
p2 <- plot_blup(model2$GY,
                prob = 0.1,
                col.shape  =  c("gray20", "gray80")) +
      coord_flip()
plot_grid(p1, p2,
          align = "v",
          labels = c("p1", "p2"),
          ncol = 1)
```


## BLUPS for genotype-vs-environment interaction

```{r }
print_table(head(model2$GY$BLUPgge))
```

## BLUP-based stability index
The WAASB index [@Olivoto2019] is a quantitative stability measure based on the weighted average of the absolute scores from the singular value decomposition of the BLUPs for genotype-vs-interaction effects and was already computed when we fitted the model with `waas()`. This statistic may be shown with `get_model_data()`.

```{r }
get_model_data(model2, what = "WAASB") %>% 
  print_table()
```


The function `Resende_indexes()` may be used to compute the harmonic mean of genotypic values (HMGV), the relative performance of the genotypic values (RPGV) and the harmonic mean of the relative performance of genotypic values (HMRPGV). See @Alves2018 for more details.

```{r }
index = model2 %>%
  Resende_indexes()
  print_table(index$GY)
```



# GGE model
## Fitting the model
The GGE model is fitted with the function `gge()`. This function produces a GGE model based on both a two-way table (in our case the object `table`) with genotypes in the rows and environments in columns, or a data.frame containing at least the columns for genotypes, environments and the response variable(s).

```{r echo = TRUE}
# Using a data.frame
gge_model = gge(data_ge, ENV, GEN, GY)

# Using a two-way table
ge_table = make_mat(data_ge, GEN, ENV, GY)
gge_model = gge(ge_table, table = TRUE)

```

## Visualizing the Biplot
The generic function `plot()` is used to generate a biplot using as input a fitted model of class `gge`.  The type of biplot is chosen by the argument `type` in the function.  Ten biplots type are available according to {@Yan2003}.

* `type = 1` A basic biplot.
* `type =  2` Mean performance vs. stability.
* `type =  3` Which-won-where.
* `type =  4` Discriminativeness vs. representativeness.
* `type =  5` Examine an environment.
* `type =  6` Ranking environments.
* `type =  7` Examine a genotype.
* `type =  8` Ranking gentoypes.
* `type =  9` Compare two genotypes.
* `type =  10` Relationship among environments.

```{r echo = TRUE, fig.width = 4, fig.height=8, message=F, warning=F}
p1 = plot(gge_model)
p2 = plot(gge_model, type = 2)
plot_grid(p1, p2,
          align = "v",
          labels = c("p1", "p2"),
          ncol = 1)
```


# Parametric and non-parametric statistics
The metan package provides an easy way to compute several world-known stability methods.
Up to the version 0.2.0, the following stability methods are implemented:

* Joint regression analysis [@Eberhart1966], using the function `ge_reg()`
* Genotypic confidence index [@Annicchiarico1992], using the function `Annicchiarico()`
* Nonparametric superiority index [@Lin1988], using the function `superiority()`
* Ecovalence [@Wricke1965], using the function `ecovalence()`
* Stability analysis and environmental stratification [@murakami2004], using the function `ge_factanal()`

The easiest way to compute the above-mentioned stability indexes is by using the function `ge_stats()`. This function basically returns a summary of each method. If you are looking for more details from each method like `plot()` and `print()`, I suggest computing that methods using their own function.

# Computing the indexes

```{r }
stat_ge <- data_ge %>% ge_stats(ENV, GEN, REP, GY)
```
If you want to export a summary of results to the working directory, the simplest way is by using the function \code{print()} with the argument \code{export = TRUE}.

# Selection based on multiple traits

The multi-trait stability index (MTSI) was proposed by @Olivoto2019a and is used for simultaneous selection considering mean performance and stability (of several traits) in the analysis of METs using both fixed and mixed-effect models. Note that a model may be fitted easier and faster using the forward-pipe `%>%` and assigning the arguments in the correct order (environment, genotype, replication and response(s) variable(s). Using `%>%` make it the coding logical and clean especially when the output of a function is used as input in a second function.

```{r, eval=FALSE, warning=FALSE}
data_ge2 %>%
  waasb(ENV, GEN, REP,
        resp = c(KW, NKE, PH, EH, TKW),
        verbose = FALSE) %>%
  mtsi(verbose = FALSE) %>%
  plot()

```



# Getting help

* The complete functionality of the metan package, combining theory, programming, and examples with outputs is described [here](https://tiagoolivoto.github.io/metan/index.html).

* If you encounter a clear bug, please file a minimal reproducible example on [github](https://github.com/TiagoOlivoto/metan/issues)

# References
