---
title: "Helper functions for metan"
author: "Tiago Olivoto"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
link-citations: true
bibliography: metanref.bib 
vignette: >
  %\VignetteIndexEntry{Helper functions for metan}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r global_options, include = FALSE}
knitr::opts_chunk$set(comment = "")
load("cvali.RData")
```


# Getting started

```{r, message=FALSE, warning=FALSE}
library(metan)
library(kableExtra) # Used to make the tables
library(tidyverse)
# Function to make HTML tables
print_table = function(table){
  kable(table, "html", digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  font_size = 12)
}

```

# Select helpers
The package `metan` reexports the  [tidy select helpers](https://tidyselect.r-lib.org/reference/select_helpers.html) and implements three own select helpers based on operations with prefixes and suffixes: `difference_var()`, `intersect_var()`, and `union_var()`.

* Variables that starts with a prefix **and** ends with a suffix.

Here, we will select the variables from `data_ge2` that starts with "C" and ends with "D".

```{r}
data_ge2 %>% 
  select(intersect_var("C", "D"))
```


* Variables that starts with a prefix **OR** ends with a suffix.

The following code select variables that starts with "C" or ends with "D".

```{r}
data_ge2 %>% 
  select(union_var("C", "D"))
```


* Variables that starts with a prefix **AND NOT** ends with a suffix.

The following code select variables that starts with "C" and not ends with "D".

```{r}
data_ge2 %>% 
  select(difference_var("C", "D"))
```


# Bind cross-validation objects

```{r, eval=FALSE }


AMMI0 <- cv_ammi(data_ge, ENV, GEN, REP, GY, naxis = 0)
AMMI2 <- cv_ammi(data_ge, ENV, GEN, REP, GY, naxis = 2)
AMMI9 <- cv_ammi(data_ge, ENV, GEN, REP, GY, naxis = 9)
AMMIF <- cv_ammif(data_ge, ENV, GEN, REP, GY)
BLUP_g <- cv_blup(data_ge, ENV, GEN, REP, GY)

```


```{r, message=FALSE, fig.height = 5, fig.width = 10, fig.align = "center" }
bind1 <- bind_cv(AMMI0, AMMI2, AMMI9)
bind2 <- bind_cv(AMMI0, AMMI2, AMMI9, bind = "means")
    ```

# Split a dataframe into subsets grouped by one or more factors
## Group data and exclude all non-numeric variables
```{r, message=FALSE, fig.height = 5, fig.width = 5.5, fig.align = "center" }
g1 <- split_factors(data_ge, ENV)
is.split_factors(g1)

```


## Group data and keep all original variables
```{r, message=FALSE, fig.height = 5, fig.width = 5.5, fig.align = "center" }
g2 <- split_factors(data_ge, ENV, GEN, keep_factors = TRUE)
print_table(g2[[1]])
```


## Group a data frame using all factor variables
```{r, message=FALSE, fig.height = 5, fig.width = 5.5, fig.align = "center" }
g3 <- as.split_factors(CO2)
names(g3)
    ```


# Make a two-way table based on categorical and numerical arguments

```{r, message=FALSE }
head(data_ge)
matrix <- make_mat(data_ge, row = GEN, col = ENV, val = GY)
print_table(matrix)

```

# Make upper and lower triangular matrices
```{r, message=FALSE }
cor_mat <- corr_coef(data_ge2, EP, EL, ED, EL, CD, CL)$cor

# Upper triangular
upp_mat <- make_upper_tri(cor_mat)
print_table(upp_mat)

# Lower triangular
low_mat <- make_lower_tri(cor_mat)
print_table(low_mat)

```

# Make a symmetric matrix

```{r, message=FALSE }
sym <- make_sym(low_mat)
print_table(sym)

```


# Reorder a correlation matrix

Reorder the correlation matrix according to the correlation coefficient by using  hclust for hierarchical clustering order. This is useful to identify the hidden pattern in the matrix.

```{r}
cor_mat
reorder_cormat(cor_mat)
```


# Compute harmonic and geometric means
```{r, message=FALSE }
num <- c(1:20, 30, 50)
hm_mean(num)
gm_mean(num)

hm_mean(data_ge2) %>% round(2)
gm_mean(data_ge2, EP, EL, CL)
```



# Generate pairwise combinations of variables by applying one function to each pair
```{r, message=FALSE}
data = data.frame(A = runif(n = 5, min = 3, max = 30),
                  B = runif(n = 5, min = 1, max = 10),
                  C = runif(n = 5, min = 9, max = 90),
                  D = runif(n = 5, min = 1, max = 90),
                  E = runif(n = 5, min = 5, max = 10))
c1 = comb_vars(data)
print_table(c1)

c2 = comb_vars(data, FUN = "*", order = "first")
print_table(c2)
    ```




# Combining data.frames by row, filling missing values

```{r, message=FALSE }
df1 = data.frame(v1 = c(1, 2), v2 = c(2, 3))
df2 = data.frame(v3 = c(4, 5))
rbind_fill(df1, df2)
rbind_fill(df1, df2, fill = "NA")
    ```

# Rescale a continuous vector to have specified minimum and maximum values
## Rescale a numeric vector
```{r, message=FALSE }
resca(values = c(1:5))

```

## Rescale using a data frame and select rescaled variables only
```{r, message=FALSE }
data_ge %>%
resca(GY, HM, new_min = 0, new_max = 1,  keep = FALSE) %>%
  head()%>%
  print_table()

```

## Rescale within factors
```{r, message=FALSE }
  data_ge2 %>% 
    select(ENV, GEN, starts_with("N"), ends_with("L")) %>%
    group_by(ENV, GEN) %>%
    summarise_all(mean) %>%
    group_by(ENV) %>%
    resca(ends_with("L")) %>%
    head(n = 13) %>%
    print_table()

```

